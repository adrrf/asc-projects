if [ -f ./tmp_zdt3p40g250/hvrefp40g250_1.out ]
then
	rm ./tmp_zdt3p40g250/hvrefp40g250_1.out
fi
if [ -f ./tmp_zdt3p40g250/hvrefp40g250_2.out ]
then
	rm ./tmp_zdt3p40g250/hvrefp40g250_2.out
fi
for j in 01 02 03 04 05 06 07 08 09 10
do
# Lee la primera columna del fichero de datos, obtiene el máximo y lo almacena en un fichero
cat ./UNKNOWN/allpop40g250seed$j.out | awk '{print $1;}' | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' > ./tmp_zdt3p40g250/hvreff$j_1.out
cat ./tmp_zdt3p40g250/hvreff$j_1.out >> ./tmp_zdt3p40g250/hvrefp40g250_1.out
# Lee la segunda columna del fichero de datos, obtiene el máximo y lo almacena en un fichero
cat ./UNKNOWN/allpop40g250seed$j.out | awk '{print $2;}' | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' > ./tmp_zdt3p40g250/hvreff$j_2.out
cat ./tmp_zdt3p40g250/hvreff$j_2.out >> ./tmp_zdt3p40g250/hvrefp40g250_2.out
done
for j in 01 02 03 04 05 06 07 08 09 099
do
cat ./EVAL10000/P40G250/zdt3_all_popmp40g250_seed$j.out | awk '{print $1;}' | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' > ./tmp_zdt3p40g250/hvrefs$j_1.out
cat ./tmp_zdt3p40g250/hvrefs$j_1.out >> ./tmp_zdt3p40g250/hvrefp40g250_1.out
cat ./EVAL10000/P40G250/zdt3_all_popmp40g250_seed$j.out | awk '{print $2;}' | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' > ./tmp_zdt3p40g250/hvrefs$j_2.out
cat ./tmp_zdt3p40g250/hvrefs$j_2.out >> ./tmp_zdt3p40g250/hvrefp40g250_2.out
done
# En este momento hvrefp40g250_1.out contiene el valor máximo del primer objetivo 
# en cada una de las 20 ejecuciones y hvrefp40g250_2.out el del segundo objetivo
# Calcula el valor máximo del primer objetivo y lo almacena en hvrefp40g250.out 
cat ./tmp_zdt3p40g250/hvrefp40g250_1.out | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' > ./tmp_zdt3p40g250/hvrefp40g250.out
# Calcula el valor máximo del segundo objetivo y lo añade a hvrefp40g250.out 
cat ./tmp_zdt3p40g250/hvrefp40g250_2.out | awk '{if(max==""){max=$1}; if($1>max) {max=$1}} END {print max}' >> ./tmp_zdt3p40g250/hvrefp40g250.out


# Ejecutamos metrics sobre cada fichero de datos con un fichero de control creado automáticamente
for j in 01 02 03 04 05 06 07 08 09 10
do
cp ./UNKNOWN/allpop40g250seed$j.out zdt3_all_popmp40g250.out
# Copiamos el fichero de control a falta del punto de referencia 
cp  zdt3p40g250stallbasic.in  zdt3p40g250stallref.in
# Añadimos al fichero de control el punto de referencia calculado anteriormente
cat ./tmp_zdt3p40g250/hvrefp40g250.out >> zdt3p40g250stallref.in
# Ejecutamos metrics
./metrics < zdt3p40g250stallref.in
# Copiamos los ficheros de resultados con otro nombre por si se quieren usar después.
cp hypervol.out ./tmp_zdt3p40g250/hypervolf$j.out
cp spacing.out ./tmp_zdt3p40g250/spacingf$j.out
done
for j in 01 02 03 04 05 06 07 08 09 099
do
cp ./EVAL10000/P40G250/zdt3_all_popmp40g250_seed$j.out zdt3_all_popmp40g250.out
cp  zdt3p40g250stallbasic.in  zdt3p40g250stallref.in
cat ./tmp_zdt3p40g250/hvrefp40g250.out >> zdt3p40g250stallref.in
./metrics < zdt3p40g250stallref.in
cp hypervol.out ./tmp_zdt3p40g250/hypervols$j.out
cp spacing.out ./tmp_zdt3p40g250/spacings$j.out
done
